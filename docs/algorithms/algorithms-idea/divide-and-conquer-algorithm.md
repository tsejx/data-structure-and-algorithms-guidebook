---
nav:
  title: 算法
  order: 2
group:
  title: 算法思想
  order: 5
title: 分治算法
order: 2
---

# 分治算法

分治算法（divide and conquer）的核心思想其实就是四个字，分而治之 ，也就是将原问题划分成 `n` 个规模较小，并且结构与原问题相似的子问题，**递归** 地解决这些子问题，然后再合并其结果，就得到原问题的解。

这个定义看起来有点类似递归的定义。关于分治和递归的区别：分治算法是一种处理问题的思想，递归是一种编程技巧。

实际上，分治算法一般都比较适合用递归来实现。分治算法的递归实现中，每一层递归都会涉及这样三个操作：

- **分解**：将原问题分解成一系列子问题；
- **解决**：递归地求解各个子问题，若子问题足够小，则直接求解；
- **合并**：将子问题的结果合并成原问题。

分治算法能解决的问题，一般需要满足下面这几个条件：

- 原问题与分解成的小问题具有相同的模式
- 原问题分解成的子问题可以独立求解，子问题之间没有相关性，这一点是分治算法跟动态规划的明显区别，等我们讲到动态规划的时候，会详细对比这两种算法
- 具有分解终止条件，也就是说，当问题足够小时，可以直接求解
- 可以将子问题合并成原问题，而这个合并操作的复杂度不能太高，否则就起不到减小算法总体复杂度的效果了

比较经典的应用就是 [归并排序（Merge Sort）](../sorting/merge-sort) 以及 [快速排序（Quick Sort）](../sorting/quick-sort) 等。我们来从归并排序理解分治思想，归并排序就是将待排序数组不断二分为规模更小的子问题处理，再将处理好的子问题合并起来。

## 经典问题
